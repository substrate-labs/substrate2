//! Procedural macros for the Substrate analog circuit generator framework.
#![warn(missing_docs)]

mod block;
mod derive;
mod geometry;
mod io;
mod pdk;
mod sim;

use darling::FromDeriveInput;
use derive::{derive_trait, DeriveInputReceiver, DeriveTrait};
use io::{IoInputReceiver, LayoutIoInputReceiver, SchematicIoInputReceiver};
use pdk::layers::{
    DerivedLayerFamilyInputReceiver, DerivedLayersInputReceiver, LayerFamilyInputReceiver,
    LayerInputReceiver, LayersInputReceiver,
};
use pdk::supported_pdks::supported_pdks_impl;
use proc_macro::TokenStream;
use proc_macro2::{Span, TokenStream as TokenStream2};
use proc_macro_crate::{crate_name, FoundCrate};
use quote::quote;
use sim::simulator_tuples_impl;
use syn::Ident;
use syn::{parse_macro_input, DeriveInput};

/// Enumerates PDKs supported by a certain layout implementation of a block.
///
/// Automatically implements the appropriate trait for all specified PDKs given a process-portable
/// implementation in a single PDK.
///
/// # Examples
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/several_layers.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/several_pdks.rs.hidden")]
#[doc = include_str!("../build/docs/block/inverter.rs.hidden")]
#[doc = include_str!("../build/docs/block/buffer.rs.hidden")]
#[doc = include_str!("../build/docs/layout/inverter_multiprocess.rs")]
#[doc = include_str!("../build/docs/layout/buffer_multiprocess.rs")]
/// ```
#[proc_macro_attribute]
pub fn supported_pdks(args: TokenStream, input: TokenStream) -> TokenStream {
    supported_pdks_impl(args, input)
}

/// Derives a layer implementation on a tuple struct containing only an ID.
///
/// # Examples
///
/// ```
/// # use substrate::Layer;
/// # use substrate::pdk::layers::LayerId;
/// #[derive(Layer, Clone, Copy)]
/// #[layer(name = "poly", gds = "66/20")]
/// pub struct Poly(LayerId);
/// ```
#[proc_macro_derive(Layer, attributes(layer))]
pub fn derive_layer(input: TokenStream) -> TokenStream {
    let receiver =
        LayerInputReceiver::from_derive_input(&parse_macro_input!(input as DeriveInput)).unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives a layer family implementation on a struct.
///
/// See the [`Layers` derive macro](`derive_layers`) for a full example.
#[proc_macro_derive(LayerFamily, attributes(layer))]
pub fn derive_layer_family(input: TokenStream) -> TokenStream {
    let receiver =
        LayerFamilyInputReceiver::from_derive_input(&parse_macro_input!(input as DeriveInput))
            .unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives a layer set implementation on a struct.
///
/// # Examples
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/layers.rs")]
/// ```
#[proc_macro_derive(Layers, attributes(layer, layer_family))]
pub fn derive_layers(input: TokenStream) -> TokenStream {
    let receiver =
        LayersInputReceiver::from_derive_input(&parse_macro_input!(input as DeriveInput)).unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives a derived layer family implementation on a struct.
///
/// See the [`DerivedLayers` derive macro](`derive_derived_layers`) for a full example.
#[proc_macro_derive(DerivedLayerFamily, attributes(layer))]
pub fn derive_derived_layer_family(input: TokenStream) -> TokenStream {
    let receiver = DerivedLayerFamilyInputReceiver::from_derive_input(&parse_macro_input!(
        input as DeriveInput
    ))
    .unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives a derived layer set implementation on a struct.
///
/// # Examples
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/several_layers.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/several_pdks.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/derived_layers.rs")]
/// ```
#[proc_macro_derive(DerivedLayers, attributes(layer_family))]
pub fn derive_derived_layers(input: TokenStream) -> TokenStream {
    let receiver =
        DerivedLayersInputReceiver::from_derive_input(&parse_macro_input!(input as DeriveInput))
            .unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives `Io` for a struct.
///
/// # Examples
///
/// By default, deriving `Io` for a struct creates general purpose schematic and layout IO structs by suffixing the
/// provided identifier with `Schematic` and `Layout`.
///
/// In the example below, `BufferIoSchematic` and `BufferIoLayout` are automatically created with default
/// settings. These are the structs that users interact with when generating schematics and layout
/// views, respectively.
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/block/buffer_io_simple.rs")]
/// ```
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
///
/// // Autogenerated by `#[derive(Io)]`.
/// pub struct BufferIoSchematic {
///     vdd: InOut<Node>,
///     vss: InOut<Node>,
///     din: Input<Node>,
///     dout: Output<Node>,
/// }
///
/// pub struct BufferIoLayout {
///     vdd: PortGeometry,
///     vss: PortGeometry,
///     din: PortGeometry,
///     dout: PortGeometry,
/// }
/// ```
///
/// However, the general purpose `PortGeometry` structs that represent the geometry of single net ports in
/// `BufferIoLayout` are often unecessary since they contain multiple shapes, whereas most
/// circuits often have a single shape for several of their ports.
///
/// Substrate allows you to customize the type of the ports you interact with when setting up IO in
/// the layout view of a block using the `#[io(layout_type = "...")]` attribute.
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/block/buffer_io.rs")]
/// ```
///
/// This indicates that the `din` and `dout` of the buffer only have a single shape, making the
/// ports easier to interact with when instantiating the buffer in other blocks.
///
/// If desired, you can even replace the whole IO struct with a layout type of your own (See
/// the [`LayoutType` derive macro](`derive_layout_type`)).
///
#[proc_macro_derive(Io, attributes(io))]
pub fn derive_io(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as DeriveInput);
    let receiver_io = IoInputReceiver::from_derive_input(&parsed).unwrap();
    let receiver_schematic = SchematicIoInputReceiver::from_derive_input(&parsed).unwrap();
    let receiver_layout = LayoutIoInputReceiver::from_derive_input(&parsed).unwrap();
    let ident = parsed.ident;
    let (imp, ty, wher) = parsed.generics.split_for_impl();
    let substrate = substrate_ident();
    quote!(
        impl #imp #substrate::io::Io for #ident #ty #wher {}
        #receiver_io
        #receiver_schematic
        #receiver_layout
    )
    .into()
}

/// Derives `LayoutType` for a struct.
///
/// # Examples
///
/// You can create your own layout types and use them as your layout IO to customize the API for
/// accessing shapes within your port. This will work as long as the flattened lengths (i.e. the
/// number of nets) of the original IO and the custom IO are the same.
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/block/buffer_io_custom_layout.rs")]
/// ```
#[proc_macro_derive(LayoutType)]
pub fn derive_layout_type(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as DeriveInput);
    let receiver_io = IoInputReceiver::from_derive_input(&parsed).unwrap();
    let receiver_layout = LayoutIoInputReceiver::from_derive_input(&parsed).unwrap();
    quote!(
        #receiver_io
        #receiver_layout
    )
    .into()
}

/// Derives `substrate::layout::Data` for a struct.
///
/// The `#[transform]` attribute annotates data that should be transformed with the enclosing instance when
/// instantiated in another block.
///
/// # Examples
///
/// This example stores the individual buffer instances within a buffer chain. The `#[transform]`
/// notes that the buffers in the data should be transformed if the buffer chain is instantiated in another
/// block and transformed.
///
/// ```
#[doc = include_str!("../build/docs/prelude.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/layers.rs.hidden")]
#[doc = include_str!("../build/docs/pdk/pdk.rs.hidden")]
#[doc = include_str!("../build/docs/block/inverter.rs.hidden")]
#[doc = include_str!("../build/docs/block/buffer.rs.hidden")]
#[doc = include_str!("../build/docs/layout/inverter.rs.hidden")]
#[doc = include_str!("../build/docs/layout/buffer.rs.hidden")]
#[doc = include_str!("../build/docs/layout/buffern_data.rs")]
/// ```
#[proc_macro_derive(LayoutData, attributes(transform))]
pub fn derive_layout_data(input: TokenStream) -> TokenStream {
    let receiver = block::layout::DataInputReceiver::from_derive_input(&parse_macro_input!(
        input as DeriveInput
    ))
    .unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives `substrate::schematic::Data` for a struct.
///
/// The `#[nested]` attribute annotates data that represents nested instances or nodes. This allows
/// Substrate to keep track of paths to nested instances and nodes for simulation purposes.
#[proc_macro_derive(SchematicData, attributes(nested))]
pub fn derive_schematic_data(input: TokenStream) -> TokenStream {
    let receiver = block::schematic::DataInputReceiver::from_derive_input(&parse_macro_input!(
        input as DeriveInput
    ))
    .unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Derives `substrate::block::Block` for a struct or enum.
///
/// You must specify the block's IO by adding a `#[block]` attribute:
/// ```skip
/// #[block(io = "TestbenchIo")]
/// pub struct MyBlock {
///   // ...
/// }
/// ```
///
/// This derive macro only works if you want to use the default value of the IO.
/// If the IO type does not implement [`Default`], or you want to use a non-default
/// value, you must implement `Block` manually.
///
/// The ID value generated by this macro will have the form
/// `mycrate::mymodule::MyBlock`. The block name function will return
/// the name of the struct/enum converted to snake case. For example, the name
/// of a block called `MyBlock` will be `my_block`.
/// If you wish to customize this behavior, consider implementing `Block` manually.
#[proc_macro_derive(Block, attributes(block))]
pub fn derive_block(input: TokenStream) -> TokenStream {
    let receiver =
        block::BlockInputReceiver::from_derive_input(&parse_macro_input!(input as DeriveInput))
            .unwrap();
    quote!(
        #receiver
    )
    .into()
}

/// Implements `substrate::simulation::Supports<Tuple> for Simulator`
/// for all tuples up to a specified max size.
#[proc_macro]
pub fn simulator_tuples(input: TokenStream) -> TokenStream {
    simulator_tuples_impl(input)
}

/// Derives `substrate::geometry::transform::TranslateMut`.
#[proc_macro_derive(TranslateMut)]
pub fn derive_translate_mut(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as DeriveInput);
    let receiver = DeriveInputReceiver::from_derive_input(&parsed).unwrap();
    let substrate = substrate_ident();
    let config = DeriveTrait {
        trait_: quote!(#substrate::geometry::transform::TranslateMut),
        method: quote!(translate_mut),
        extra_arg_idents: vec![quote!(__substrate_derive_point)],
        extra_arg_tys: vec![quote!(#substrate::geometry::point::Point)],
    };

    let expanded = derive_trait(&config, receiver);
    proc_macro::TokenStream::from(expanded)
}

/// Derives `substrate::geometry::transform::TransformMut`.
#[proc_macro_derive(TransformMut)]
pub fn derive_transform_mut(input: TokenStream) -> TokenStream {
    let parsed = parse_macro_input!(input as DeriveInput);
    let receiver = DeriveInputReceiver::from_derive_input(&parsed).unwrap();
    let substrate = substrate_ident();
    let config = DeriveTrait {
        trait_: quote!(#substrate::geometry::transform::TransformMut),
        method: quote!(transform_mut),
        extra_arg_idents: vec![quote!(__substrate_derive_transformation)],
        extra_arg_tys: vec![quote!(#substrate::geometry::transform::Transformation)],
    };

    let expanded = derive_trait(&config, receiver);
    proc_macro::TokenStream::from(expanded)
}

pub(crate) fn substrate_ident() -> TokenStream2 {
    match crate_name("substrate").expect("substrate is present in `Cargo.toml`") {
        FoundCrate::Itself => quote!(::substrate),
        FoundCrate::Name(name) => {
            let ident = Ident::new(&name, Span::call_site());
            quote!(::#ident)
        }
    }
}
