//! Executor (e.g. LSF, Slurm) API.

use std::any::Any;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::sync::Arc;

/// Job submission options.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ExecOpts {
    /// Number of CPUs to use.
    pub cpus: Option<usize>,
    /// Number of machines to use.
    pub machines: usize,
    /// Where to place logs.
    pub logs: LogOutput,
}

impl Default for ExecOpts {
    #[inline]
    fn default() -> Self {
        Self {
            cpus: None,
            machines: 1,
            logs: LogOutput::Stdio,
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq, Default)]
/// Where to place logs generated by a job.
pub enum LogOutput {
    /// Save logs to standard output and standard error.
    #[default]
    Stdio,
    /// Save logs to a file.
    File(PathBuf),
}

/// A job executor.
pub trait Executor: Any + Send + Sync {
    /// Execute the given command with the given options, waiting until the command completes.
    fn execute(&self, command: Command, opts: ExecOpts) -> Result<(), crate::error::Error>;
}

/// Executes commands locally.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, Default)]
pub struct LocalExecutor;

impl Executor for LocalExecutor {
    fn execute(&self, mut command: Command, opts: ExecOpts) -> Result<(), crate::error::Error> {
        if let LogOutput::File(ref path) = opts.logs {
            let fout = std::fs::File::create(path).map_err(Arc::new)?;
            let ferr = fout.try_clone().map_err(Arc::new)?;
            command.stdout(Stdio::from(fout)).stderr(Stdio::from(ferr));
        }

        let status = command.status().map_err(Arc::new)?;
        if !status.success() {
            return Err(crate::error::Error::CommandFailed(Arc::new(command)));
        }

        Ok(())
    }
}
