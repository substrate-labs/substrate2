//! Macros for the `enumify` crate.
#![warn(missing_docs)]

use proc_macro::TokenStream;

use proc_macro_error::proc_macro_error;

use crate::impls::Enumify;
use syn::{parse_macro_input, DeriveInput};

pub(crate) mod impls;

/// Implement enum helper functions.
///
/// This adds implementations for `as_ref`, `as_mut`,
/// and other helpers.
///
/// # Examples
///
/// Consider an enum like this:
///
/// ```
/// # use std::sync::Arc;
/// pub enum ArcNumber {
///   Float(Arc<f64>),
///   Int(Arc<u64>),
/// }
/// ```
///
/// With `enumify`, you can write the following:
///
/// ```
/// # use std::sync::Arc;
/// # use enumify_macros::enumify;
/// #[enumify]
/// pub enum ArcNumber {
///   Float(Arc<f64>),
///   Int(Arc<u64>),
/// }
///
/// let x = ArcNumber::Int(Arc::new(123));
/// let inner: &Arc<u64> = x.as_ref().unwrap_int();
/// assert_eq!(**inner, 123);
/// ```
///
/// If you do not need `as_ref` or `as_mut` implementations and would like to avoid
/// creating auxiliary structs, you can write the following:
///
/// ```
/// # use std::sync::Arc;
/// # use enumify_macros::enumify;
/// #[derive(Clone, Copy)]
/// #[enumify(no_as_ref, no_as_mut)]
/// pub enum Number {
///   Float(f64),
///   Int(u64),
/// }
///
/// let x = Number::Int(123);
/// let inner: u64 = x.unwrap_int();
/// assert_eq!(inner, 123);
/// assert!(x.is_int());
/// ```
///
/// If you want to create a general purpose enum like a [`Result`] where `as_ref` and
/// `as_mut` implementations do not require creating a new struct, you can write this:
///
/// ```
/// # use std::sync::Arc;
/// # use enumify_macros::enumify;
/// #[enumify(generics_only)]
/// pub enum Number<F, I> {
///   Float(F),
///   Int(I),
/// }
///
/// pub type ArcNumber = Number<Arc<f64>, Arc<u64>>;
/// pub type BoxNumber = Number<Box<f64>, Box<u64>>;
///
/// let x = ArcNumber::Int(Arc::new(123));
/// let inner: &Arc<u64> = x.as_ref().unwrap_int();
/// assert_eq!(**inner, 123);
///
/// let x = BoxNumber::Int(Box::new(123));
/// let inner: &Box<u64> = x.as_ref().unwrap_int();
/// assert_eq!(**inner, 123);
/// ```
///
/// By default, the enumify macro adds the following methods:
/// * `as_ref`, which converts `&MyEnum<T, U>` to `MyEnum<&T, &U>`
/// * `as_mut`, which converts `&mut MyEnum<T, U>` to `MyEnum<&mut T, &mut U>`
/// * `is_{variant}`, which returns `true` if the enum value is the given variant.
///
/// The following methods are generated only for tuple enum variants with a single field:
/// * `unwrap_{variant}`, which asserts that an enum value is a particular variant, and returns the
///    inner value. Only generated for tuple enum variants with a single field.
/// * `get_{variant}`, which returns an `Option<&T>` where `T` is the type of the
///    inner value of the given variant. If the enum value is the desired variant, returns
///    `Some` and a reference to the inner value. Otherwise, returns `None`.
/// * `into_{variant}`, which returns an `Option<T>` where `T` is the type of the
///    inner value of the given variant. If the enum value is the desired variant, returns
///    `Some` and the inner value. Otherwise, returns `None`.
///
/// An example `enumify` usage along with relevant parts of the autogenerated code is provided below:
/// ```
/// # use enumify_macros::enumify;
/// #[enumify]
/// pub enum ExampleEnum {
///   VariantA(u64),
///   VariantB(f64),
///   VariantC(u64, f64),
///   VariantD { d: f64 },
/// }
///
/// // BEGIN AUTOGENERATED CODE
/// # mod namespace {
/// # use std::unimplemented;
/// pub enum ExampleEnum {
/// #   VariantA(u64),
/// #   VariantB(f64),
/// #   VariantC(u64, f64),
/// #   VariantD { d: f64 },
/// # }
/// // Implements the same methods as `ExampleEnum`.
/// pub enum ExampleEnumRef<A, B, C, D, E> {
///     VariantA(A),
///     VariantB(B),
///     VariantC(C, D),
///     VariantD { d: E },
/// }
///
/// impl ExampleEnum {
///     /// Converts types to references.
///     ///
///     /// For example, transforms a variant field with type `T` to `&T`.
///     fn as_ref(&self) -> ExampleEnumRef<&u64, &f64, &u64, &f64, &f64> {
///         # unimplemented!()
///         // ...
///     }
///     /// Converts types to mutable references.
///     ///
///     /// For example, transforms a variant field with type `T` to `&mut T`.
///     fn as_mut(&self) -> ExampleEnumRef<&mut u64, &mut f64, &mut u64, &mut f64, &mut f64> {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns true if this value is the expected variant.
///     fn is_variant_a(&self) -> bool {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns true if this value is the expected variant.
///     fn is_variant_b(&self) -> bool {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns true if this value is the expected variant.
///     fn is_variant_c(&self) -> bool {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns true if this value is the expected variant.
///     fn is_variant_d(&self) -> bool {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns the value contained in this variant.
///     ///
///     /// # Panics
///     ///
///     /// Panics if the enum value is not of the expected variant.
///     fn unwrap_variant_a(self) -> u64 {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns a reference to the value contained in this variant.
///     ///
///     /// Returns [`None`] if the enum value is not of the expected variant.
///     fn get_variant_a(&self) -> Option<&u64> {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns the value contained in this variant.
///     ///
///     /// Returns [`None`] if the enum value is not of the expected variant.
///     fn into_variant_a(&self) -> Option<u64> {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns the value contained in this variant.
///     ///
///     /// # Panics
///     ///
///     /// Panics if the enum value is not of the expected variant.
///     fn unwrap_variant_b(self) -> u64 {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns a reference to the value contained in this variant.
///     ///
///     /// Returns [`None`] if the enum value is not of the expected variant.
///     fn get_variant_b(&self) -> Option<&u64> {
///         # unimplemented!()
///         // ...
///     }
///     /// Returns the value contained in this variant.
///     ///
///     /// Returns [`None`] if the enum value is not of the expected variant.
///     fn into_variant_b(&self) -> Option<u64> {
///         # unimplemented!()
///         // ...
///     }
/// }
/// # }
/// // END AUTOGENERATED CODE
/// ```
#[proc_macro_error]
#[proc_macro_attribute]
pub fn enumify(args: TokenStream, input: TokenStream) -> TokenStream {
    let mut enumval = input.clone().into();
    let data = match Enumify::new(args.into(), &parse_macro_input!(input as DeriveInput)) {
        Ok(data) => data,
        Err(tokens) => return tokens.into(),
    };
    data.expand(&mut enumval);
    enumval.into()
}
