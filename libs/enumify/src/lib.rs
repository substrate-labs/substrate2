//! A crate for providing automatic enum utilities.
//!
//! # Example
//!
//! Consider an enum like this:
//!
//! ```
//! # use std::sync::Arc;
//! pub enum ArcNumber {
//!   Float(Arc<f64>),
//!   Int(Arc<u64>),
//! }
//! ```
//!
//! With `enumify`, you can write the following:
//!
//! ```
//! # use std::sync::Arc;
//! #[enumify::enumify]
//! pub enum ArcNumber {
//!   Float(Arc<f64>),
//!   Int(Arc<u64>),
//! }
//!
//! let x = ArcNumber::Int(Arc::new(123));
//! let inner: &Arc<u64> = x.as_ref().unwrap_int();
//! assert_eq!(**inner, 123);
//! ```
//!
//! If you do not need `as_ref` or `as_mut` implementations and would like to avoid
//! creating auxiliary structs, you can write the following:
//!
//! ```
//! # use std::sync::Arc;
//! #[derive(Clone, Copy)]
//! #[enumify::enumify(no_as_ref, no_as_mut)]
//! pub enum Number {
//!   Float(f64),
//!   Int(u64),
//! }
//!
//! let x = Number::Int(123);
//! let inner: u64 = x.unwrap_int();
//! assert_eq!(inner, 123);
//! assert!(x.is_int());
//! ```
//!
//! If you want to create a general purpose enum like a [`Result`] where `as_ref` and
//! `as_mut` implementations do not require creating a new struct, you can write this:
//!
//! ```
//! # use std::sync::Arc;
//!
//! #[enumify::enumify(generics_only)]
//! pub enum Number<F, I> {
//!   Float(F),
//!   Int(I),
//! }
//!
//! pub type ArcNumber = Number<Arc<f64>, Arc<u64>>;
//! pub type BoxNumber = Number<Box<f64>, Box<u64>>;
//!
//! let x = ArcNumber::Int(Arc::new(123));
//! let inner: &Arc<u64> = x.as_ref().unwrap_int();
//! assert_eq!(**inner, 123);
//!
//! let x = BoxNumber::Int(Box::new(123));
//! let inner: &Box<u64> = x.as_ref().unwrap_int();
//! assert_eq!(**inner, 123);
//! ```
//!
//! By default, the enumify macro adds the following methods:
//! * `as_ref`, which converts `&MyEnum<T, U>` to `MyEnum<&T, &U>`
//! * `as_mut`, which converts `&mut MyEnum<T, U>` to `MyEnum<&mut T, &mut U>`
//! * `unwrap_{variant}`, which asserts that an enum value is a particular variant, and returns the
//!    inner value. Only generated for tuple enum variants with a single field.
//! * `is_{variant}`, which returns `true` if the enum value is the given variant.

pub use enumify_macros::*;

#[cfg(test)]
mod tests {
    use enumify_macros::enumify;
    use std::sync::Arc;

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[enumify]
    #[allow(unused)]
    enum ComprehensiveEnum {
        Struct {
            x: String,
            y: String,
            z: u64,
        },
        Tuple(String, String),
        AnotherStruct {
            a: String,
            b: u64,
            c: u32,
            d: Arc<bool>,
        },
        Unit,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[enumify(no_as_ref, no_as_mut)]
    enum NoAsRefEnum {
        Variant,
    }

    // Assert that this name is not taken by an autogenerated struct.
    #[allow(unused)]
    enum NoAsRefEnumRef {}

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[enumify(generics_only)]
    enum GenericsOnlyEnum<A, B, C, D, E, F, G, H, I> {
        Struct { x: A, y: B, z: C },
        Tuple(D, E),
        AnotherStruct { a: F, b: G, c: H, d: I },
        Unit,
    }

    // Assert that this name is not taken by an autogenerated struct.
    #[allow(unused)]
    enum GenericsOnlyEnumRef {}

    fn mt() -> String {
        "".into()
    }

    #[test]
    fn comprehensive_enum() {
        let mut ce = ComprehensiveEnum::Struct {
            x: mt(),
            y: mt(),
            z: 0,
        };
        assert!(ce.is_struct());
        if let ComprehensiveEnumRef::Struct { z, .. } = ce.as_mut() {
            *z = 5;
        }
        assert_eq!(
            ce,
            ComprehensiveEnum::Struct {
                x: mt(),
                y: mt(),
                z: 5
            }
        )
    }

    #[test]
    fn no_as_ref_enum() {
        let nar = NoAsRefEnum::Variant;
        assert!(nar.is_variant());
    }

    #[test]
    fn generics_only_enum() {
        let mut go: GenericsOnlyEnum<
            String,
            String,
            u64,
            String,
            String,
            String,
            u64,
            u32,
            Arc<bool>,
        > = GenericsOnlyEnum::Struct {
            x: mt(),
            y: mt(),
            z: 5,
        };
        assert!(go.is_struct());
        if let GenericsOnlyEnum::Struct { z, .. } = go.as_mut() {
            *z = 5;
        }
        assert_eq!(
            go,
            GenericsOnlyEnum::Struct {
                x: mt(),
                y: mt(),
                z: 5
            }
        )
    }
}
