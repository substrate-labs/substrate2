//! A crate for providing automatic enum utilities.
//!
//! # Example
//!
//! Consider an enum like this:
//!
//! ```
//! # use std::sync::Arc;
//! pub enum ArcNumber {
//!   Float(Arc<f64>),
//!   Int(Arc<u64>),
//! }
//! ```
//!
//! With `enumify`, you can write the following:
//!
//! ```
//! # use std::sync::Arc;
//! #[enumify::enumify]
//! pub enum ArcNumber {
//!   Float(Arc<f64>),
//!   Int(Arc<u64>),
//! }
//!
//! let x = ArcNumber::Int(Arc::new(123));
//! let inner: &Arc<u64> = x.as_ref().unwrap_int();
//! assert_eq!(**inner, 123);
//! ```
//!
//! See the [`enumify`] macro for more details.

pub use enumify_macros::*;

#[cfg(test)]
mod tests {
    use enumify_macros::enumify;
    use std::sync::Arc;

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[enumify]
    #[allow(unused)]
    enum ComprehensiveEnum {
        Struct {
            x: String,
            y: String,
            z: u64,
        },
        Tuple(String, String),
        AnotherStruct {
            a: String,
            b: u64,
            c: u32,
            d: Arc<bool>,
        },
        Unit,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[enumify(no_as_ref, no_as_mut)]
    enum NoAsRefEnum {
        Variant,
    }

    // Assert that this name is not taken by an autogenerated struct.
    #[allow(unused)]
    enum NoAsRefEnumRef {}

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[enumify(generics_only)]
    enum GenericsOnlyEnum<A, B, C, D, E, F, G, H, I> {
        Struct { x: A, y: B, z: C },
        Tuple(D, E),
        AnotherStruct { a: F, b: G, c: H, d: I },
        Unit,
    }

    // Assert that this name is not taken by an autogenerated struct.
    #[allow(unused)]
    enum GenericsOnlyEnumRef {}

    #[derive(Debug, Clone, PartialEq, Eq)]
    #[allow(unused)]
    #[enumify]
    enum PartialGenericsEnum<A, B> {
        Struct {
            x: A,
            y: String,
            z: u64,
        },
        Tuple(B, String),
        AnotherStruct {
            a: String,
            b: u64,
            c: u32,
            d: Arc<bool>,
        },
        Unit,
    }

    fn mt() -> String {
        "".into()
    }

    #[test]
    fn comprehensive_enum() {
        let mut ce = ComprehensiveEnum::Struct {
            x: mt(),
            y: mt(),
            z: 0,
        };
        assert!(ce.is_struct());
        if let ComprehensiveEnumRef::Struct { z, .. } = ce.as_mut() {
            *z = 5;
        }
        assert_eq!(
            ce,
            ComprehensiveEnum::Struct {
                x: mt(),
                y: mt(),
                z: 5
            }
        )
    }

    #[test]
    fn no_as_ref_enum() {
        let nar = NoAsRefEnum::Variant;
        assert!(nar.is_variant());
    }

    #[test]
    fn generics_only_enum() {
        let mut go: GenericsOnlyEnum<
            String,
            String,
            u64,
            String,
            String,
            String,
            u64,
            u32,
            Arc<bool>,
        > = GenericsOnlyEnum::Struct {
            x: mt(),
            y: mt(),
            z: 5,
        };
        assert!(go.is_struct());
        if let GenericsOnlyEnum::Struct { z, .. } = go.as_mut() {
            *z = 5;
        }
        assert_eq!(
            go,
            GenericsOnlyEnum::Struct {
                x: mt(),
                y: mt(),
                z: 5
            }
        )
    }

    #[test]
    fn partial_generics_enum() {
        let mut go: PartialGenericsEnum<String, String> = PartialGenericsEnum::Struct {
            x: mt(),
            y: mt(),
            z: 5,
        };
        assert!(go.is_struct());
        if let PartialGenericsEnumRef::Struct { z, .. } = go.as_mut() {
            *z = 5;
        }
        assert_eq!(
            go,
            PartialGenericsEnum::Struct {
                x: mt(),
                y: mt(),
                z: 5
            }
        )
    }
}
