---
sidebar_position: 3
---

# Layout API

Making a layout involves creating a cell, generating instances, and drawing those instances.
The IO of the cell must also be populated with the relevant port geometry.

Specifically, creating a voltage divider layout looks something like this:

```rust
impl HasLayout for VDivider {
  type Data = ();

  fn layout(&self, ctx: &Context) -> SubstrateResult<LayoutCell> {
    let schematic = ctx.get_schematic_cell::<VDivider>();
    let mut cell = ctx.layout_cell_builder::<VDivider>();

    let r1: LayoutInstance<Resistor> = ctx.generate_layout(schematic.data.r1.block.clone());
    let mut r2: LayoutInstance<Resistor> = ctx.generate_layout(schematic.data.r2.block.clone());

    r2.align_centers(r1);
    r2.align_above(r1);

    cell.draw(LayoutRect::new(m0, r1.io.n.union(r2.io.p)))

    cell.draw(r1);
    cell.draw(r2);

    Ok(cell.finish(()))
  }
}
```

The main difference between the layout and schematic APIs is that layout 
instances must be generated by the context before they are added to the cell. This is because 
layout instances need to be mutable, and for tiling it is often desirable to clone instances 
and move them before adding them to the cell.

:::caution
The above example doesn't specify port geometry as this has not yet been designed yet. However, it would be nice
to enforce that geometry is specified in some manner.
:::

## Layout-Schematic Matching

In the example above, `ctx.get_schematic_cell::<VDivider>()` is used to grab the schematic from the layout generator. However, the schematic is not always generated before the layout.

The way we infer dependencies is by caching generated blocks. So, if the schematic happens 
to be generated the layout, we just use the cached version when we query it in the layout. 
If the schematic is not generated before the layout queries it, the layout generates it 
before continuing. In the case where the schematic depends on the layout, the 
schematic would simply call a corresponding `ctx.get_layout_cell::<VDivider>()`.

:::note
This breaks if there are circular dependencies (which causes infinite recursion), but this is a reasonable result
of encoding mutual dependence. Rust itself doesn't have a mechanism for preventing mutual recursion anyways.
:::
