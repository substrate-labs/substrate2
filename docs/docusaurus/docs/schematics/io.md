---
sidebar_position: 1
---

import CodeSnippet from '@site/src/components/CodeSnippet';
export const vdividerMod = require(`{{EXAMPLES}}/spice_vdivider/src/lib.rs?snippet`);
export const core = require(`{{EXAMPLES}}/substrate_api_examples/src/lib.rs?snippet`);

# IOs

In this section, we'll explore how to define and use the interfaces between generated schematics.

## Defining an IO

The first step in creating a Substrate schematic generator is to define an interface that other generators can use to instantiate your generator. An interface, called an IO in Substrate, defines a set of ports and their directions.

<CodeSnippet language="rust" snippet="vdivider-io">{vdividerMod}</CodeSnippet>

An IO must implement the [`Io`] trait. Implementing this trait is most easily done by using `#[derive(Io)]`.

## Bundle kinds

The IO struct itself does not store any connectivity data, but rather is a template for what an instantiation of the IO should look like. Specifically, an IO struct has an associated **directionality** and **bundle kind**.

Directionality means that each signal in the IO has an associated direction (input, output, or inout). A bundle kind is an undirectioned template describing what data is stored in its associated bundles.
`VdividerIo::default()`, for example, would describe an IO template where the `dout` port should be an output signal. `VdividerIo` has bundle kind `VdividerIoKind`, which is
auto-generated by `#[derive(Io)]`. The bundle kind declares that `dout` should be a single-bit signal, but does not declare the direction.

If we want to declare a bundle kind that does not have inherent directions, we can use the [`#[derive(BundleKind)]`]({{API}}/substrate/types/derive.BundleKind.html) macro.

<CodeSnippet language="rust" snippet="diff-pair">{core}</CodeSnippet>

We can then use the IOs `Input<DiffPair>`, `Output<DiffPair>`, and `InOut<DiffPair>`, which all have bundle kind `DiffPair`.

### Runtime configuration

Some bundle kinds can be configured at runtime. For example, we can also describe an IO containing two 5-bit buses as follows:

<CodeSnippet language="rust" snippet="array-io">{core}</CodeSnippet>

This allows you to parametrize the contents of your interface at runtime in whatever way you like. For example, we can do some calculations in the constructor for `ArrayIo`:

<CodeSnippet language="rust" snippet="array-io-constructor">{core}</CodeSnippet>

### Port directions

Since port direction rules are often broken in analog design, Substrate does not enforce any directionality checks when connecting two ports. However, Substrate does run a basic driver analysis that throws warnings if there are multiple drivers of a net or no drivers, which may be helpful for debugging purposes.

All IOs implement the [`Directed`] trait, 
which allows them to specify the direction of each of their constituent ports. 
Wrapping a signal with one of the 
[`Input`], 
[`Output`], or 
[`InOut`] wrapper types allows you to specify the direction of different components of the IO.
All IO ports must have a specified direction.

Wrapping a composite type with a direction will overwrite the direction of all constituent signals. 
In the example below, all of the ports of `SramObserverIo` are inputs.

<CodeSnippet language="rust" snippet="sram-io">{core}</CodeSnippet>

Similarly, if we wanted to create an `SramDriverIo` that drives the input signals of an SRAM and 
reads the output, we can use the [`Flipped`] wrapper type, which flips the 
direction of each constituent port.

<CodeSnippet language="rust" snippet="sram-driver-io">{core}</CodeSnippet>


## Bundles

Since bundle kind structs only define the properties of an interface, a separate struct is needed to store 
connectivity data for the signals and buses defined by the IO struct. This struct is called a 
**bundle** and is associated with an IO struct via the 
[`SchematicBundleKind`] trait.

A bundle essentially just stores what each port in the IO is connected to and is created when the schematic type described by an IO struct is instantiated. In the case of the `VdividerIo` given before, the `#[derive(Io)]` macro automatically generates an appropriate schematic bundle
that looks something like this:

```rust
pub struct VdividerIoView<NodeBundle> {
    pub vdd: Node,
    pub vss: Node,
    pub dout: Node,
}
```

While IO structs describe the type of an interface, bundles describe the data of an interface and represent the physical wires (`Node`s) in a netlist. As such, bundles can be connected to one another and probed during simulation.
The bundle kind of a bundle can be found using [`HasBundleKind::kind`].

## Connections

Substrate can connect any two bundles that have the same bundle kind. For example, two bundles with
kind `Array::new(5)` can be connected to one another, but a bundle with kind `Array::new(5)` cannot
be connected to a bundle with kind `Array::new(6)`.

Connections are made between two bundles by flattening bundles into an array of 
constituent wires and connecting these wires in order. As such, only bundles of the same 
bundle kind can be connected since Substrate cannot make any assumptions 
on the ordering of wires in different bundle kinds.

### Custom connections

Sometimes, you might want to connect bundles of different kinds. By default, Substrate does not allow this
because it cannot infer how signals should be connected.
However, it does allow you to define [`DataView`]s to explicitly declare how two bundles of different kinds
should be connected.

Suppose we have the following two IOs:

<CodeSnippet language="rust" snippet="mos-io">{core}</CodeSnippet>

The following code can be used to define a conversion from one IO's bundle to the other:

<CodeSnippet language="rust" snippet="mos-io-data-view">{core}</CodeSnippet>

We can then connect the corresponding bundles as follows:

<CodeSnippet language="rust" snippet="connect-data-views">{core}</CodeSnippet>

However, sometimes, we might want to tie the body port to a separate node. We can do
this using an auxiliary bundle kind:

<CodeSnippet language="rust" snippet="mos-io-data-view-advanced">{core}</CodeSnippet>

We can then connect the desired signals:

<CodeSnippet language="rust" snippet="connect-data-views-advanced">{core}</CodeSnippet>

### Arbitrary connections

If you would like to connect two bundles of different kinds and know that they can be connected
without any reordering/re-mapping of signals, you can flatten both to arrays and connect them.
This is not recommended since it is almost always better to use an explicit data view, but
it can come in handy when you just want to test something quickly or
you do not really care about the order of the bits.

For example, suppose we have two IOs that have the same constituent signals, but are
different kinds (perhaps they were defined in different crates):

<CodeSnippet language="rust" snippet="arbitrary-connect-ios">{core}</CodeSnippet>

We can connect bundles of these IOs as follows:

<CodeSnippet language="rust" snippet="arbitrary-connect">{core}</CodeSnippet>


[`Io`]: {{API}}/substrate/types/trait.Io.html
[`Directed`]: {{API}}/substrate/types/trait.Directed.html
[`Input`]: {{API}}/substrate/types/struct.Input.html
[`Output`]: {{API}}/substrate/types/struct.Input.html
[`InOut`]: {{API}}/substrate/types/struct.In.html
[`Flipped`]: {{API}}/substrate/types/struct.Flipped.html
[`SchematicBundleKind`]: {{API}}/substrate/types/schematic/trait.SchematicBundleKind.html
[`Connect`]: {{API}}/substrate/types/trait.Connect.html
[`DataView`]: {{API}}/substrate/types/schematic/trait.DataView.html
[`HasBundleKind::kind`]: {{API}}/substrate/types/trait.HasBundleKind.html#tymethod.kind
